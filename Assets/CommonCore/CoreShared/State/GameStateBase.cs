using CommonCore.Config;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using System.Security.Cryptography;
using System.Text;
using UnityEngine;

namespace CommonCore.State
{
    //DO NOT EDIT THIS FILE

    /// <summary>
    /// Represents the entire state of the game
    /// </summary>
    public partial class GameState : IMigratable
    {
        private static GameState instance;

        public static GameState Instance => instance;

        public static bool Exists => Instance != null;

        /// <summary>
        /// Purges the current game state and recreates it
        /// </summary>
        /// <remarks>Does not run initialization</remarks>
        public static void Recreate()
        {
            instance = new GameState();
        }

        /// <summary>
        /// Purges the current game state
        /// </summary>
        public static void Clear()
        {
            instance = null;
        }

        /// <summary>
        /// Saves the current game state to file
        /// </summary>
        public static void SerializeToFile(string path)
        {
            string data = Serialize();
            File.WriteAllText(path, data);
        }

        /// <summary>
        /// Serializes the current game state to a JObject
        /// </summary>
        public static JObject SerializeToJObject()
        {
            Instance.CurrentVersion = CoreParams.GetCurrentVersion();
            return JObject.FromObject(Instance, JsonSerializer.Create(CoreParams.DefaultJsonSerializerSettings));
        }

        /// <summary>
        /// Serializes the current game state to a string
        /// </summary>
        public static string Serialize()
        {
            Instance.CurrentVersion = CoreParams.GetCurrentVersion();
            return JsonConvert.SerializeObject(Instance,
                Formatting.Indented,
                CoreParams.DefaultJsonSerializerSettings);
        }

        /// <summary>
        /// Loads a file into the current game state
        /// </summary>
        public static void DeserializeFromFile(string path)
        {
            Deserialize(File.ReadAllText(path));
        }

        /// <summary>
        /// Loads a JObject into the current game state
        /// </summary>
        public static void DeserializeFromJObject(JObject jObject)
        {
            instance = jObject.ToObject<GameState>(JsonSerializer.Create(CoreParams.DefaultJsonSerializerSettings));
        }

        /// <summary>
        /// Deserializes a string and replaces the current game state
        /// </summary>
        public static void Deserialize(string data)
        {
            instance = JsonConvert.DeserializeObject<GameState>(data,
            CoreParams.DefaultJsonSerializerSettings);
        }

        /// <summary>
        /// Loads initial values into the current game state, creating a new instance if it does not exist
        /// </summary>
        public static void LoadInitial()
        {
            if (instance == null)
            {
                instance = new GameState();
            }

            instance.Init();
            instance.SetCampaignStartDate();
            instance.SetCampaignHash();
            instance.LastMigratedVersion = instance.CurrentVersion;
        }

        /// <summary>
        /// Loads initial values into the current game state
        /// </summary>
        private void Init()
        {
            //we actually use reflection to get all "decorated" methods and run them

            var initMethods = GetType().GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance)
                .Where(m => m.GetCustomAttributes(typeof(InitAttribute), false).Length > 0)
                .ToList();

            if (initMethods.Count == 0)
                return; //abort if no init methods available
            else if (initMethods.Count == 1)
                initMethods[0].Invoke(this, null); //if we only have one, it's easy
            else
            {
                initMethods.Sort((m1, m2) => ((InitAttribute)m2.GetCustomAttributes(typeof(InitAttribute), false)[0]).Priority
                .CompareTo(((InitAttribute)m1.GetCustomAttributes(typeof(InitAttribute), false)[0]).Priority));
                foreach (var m in initMethods)
                    m.Invoke(this, null);
            }

            InitialLoaded = true;
        }

        /// <summary>
        /// Calculates and sets the campaign hash
        /// </summary>
        private void SetCampaignHash()
        {
            if(CoreParams.UseCampaignIdentifier && ConfigState.Instance.UseCampaignIdentifier)
            {
                StringBuilder campaignDescriptor = new StringBuilder(1024);

                var rnd = new System.Random();

                campaignDescriptor.Append(CoreParams.GameName + CoreParams.GameVersion.ToString() + CoreParams.UnityVersionName); //game descriptor
                campaignDescriptor.Append(Environment.UserName + Environment.MachineName + Environment.OSVersion.ToString()); //machine descriptor
                campaignDescriptor.Append(DateTime.Now.ToString() + rnd.Next().ToString()); //session descriptor

                //UnityEngine.Debug.LogError(campaignDescriptor);

                using (HashAlgorithm algo = SHA1.Create())
                {
                    byte[] result = algo.ComputeHash(Encoding.UTF8.GetBytes(campaignDescriptor.ToString()));
                    CampaignIdentifier = BitConverter.ToString(result).Replace("-", string.Empty);
                }
            }
            else
            {
                CampaignIdentifier = "0000000000000000000000000000000000000000";
            }

        }

        /// <summary>
        /// Sets the campaign start date if enabled
        /// </summary>
        private void SetCampaignStartDate()
        {
            if(CoreParams.UseCampaignStartDate)
            {
                CampaignStartDate = DateTime.Now;
            }
            else
            {
                CampaignStartDate = DateTime.MinValue;
            }
        }

        /// <summary>
        /// Runs handling after GameState is deserialized 
        /// </summary>
        [OnDeserialized]
        private void HandleOnDeserialized(StreamingContext context)
        {
            var loadMethods = GetType().GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance)
                .Where(m => m.GetCustomAttributes(typeof(AfterLoadAttribute), false).Length > 0)
                .ToList();

            if (loadMethods.Count == 0)
                return;
            else if (loadMethods.Count == 1)
                loadMethods[0].Invoke(this, null);
            else
            {
                loadMethods.Sort((m1, m2) => ((AfterLoadAttribute)m2.GetCustomAttributes(typeof(AfterLoadAttribute), false)[0]).Priority
                .CompareTo(((AfterLoadAttribute)m1.GetCustomAttributes(typeof(AfterLoadAttribute), false)[0]).Priority));
                foreach (var m in loadMethods)
                    m.Invoke(this, null);
            }
        }

        //our first "migration": sets LastMigratedVersion if not already set
        [Obsolete] //TODO use actual migrations
        private static void MigrateLastMigratedVersion(GameState gs)
        {
            if (gs.LastMigratedVersion == null)
            {
                gs.LastMigratedVersion = CoreParams.GetCurrentVersion();
                Debug.Log($"[GameState] Migrated to {gs.LastMigratedVersion} ({nameof(MigrateLastMigratedVersion)})");
            }
        }

        //metadata for save games

        /// <summary>
        /// Version information of the initial state or last migration
        /// </summary>
        [JsonProperty]
        public VersionInfo LastMigratedVersion { get; private set; } //defaults to null so we can identify saves before this property existed

        /// <summary>
        /// Version information of the current state
        /// </summary>
        [JsonProperty]
        public VersionInfo CurrentVersion { get; private set; } = CoreParams.GetCurrentVersion();

        Version IMigratable.LastMigratedVersion => LastMigratedVersion.GameVersion;

        //should these be accessible?
        [JsonProperty]
        private string GameName => CoreParams.GameName;
        [JsonProperty]
        private string CompanyName => CoreParams.CompanyName;

        //basic game data to be shared across games

        /// <summary>
        /// Generic data store for global game state
        /// </summary>
        public Dictionary<string, object> GlobalDataState { get; private set; } = new Dictionary<string, object>();

        /// <summary>
        /// Generic data store for scene-local game state
        /// </summary>
        public Dictionary<string, Dictionary<string, object>> LocalDataState { get; private set; } = new Dictionary<string, Dictionary<string, object>>();

        /// <summary>
        /// State data of the world time
        /// </summary>
        public WorldTimeModel WorldTimeState { get; private set; } = new WorldTimeModel();

        /// <summary>
        /// The current scene we are in
        /// </summary>
        public string CurrentScene { get; set; }

        /// <summary>
        /// If modifying gamestate (inventory, RPG, etc) from menus is disallowed
        /// </summary>
        public bool MenuGameStateLocked { get; set; }

        /// <summary>
        /// If any saving is disallowed at this point
        /// </summary>
        public bool SaveLocked { get; set; }

        /// <summary>
        /// If we are disallowed from manually saving at this point
        /// </summary>
        public bool ManualSaveLocked { get; set; }

        /// <summary>
        /// If we are allowed to open the menu at this point
        /// </summary>
        public bool MenuLocked { get; set; }

        /// <summary>
        /// Whether we have loaded initial data already
        /// </summary>
        [JsonProperty]
        public bool InitialLoaded { get; private set; }

        /// <summary>
        /// A unique value identifying this game instance
        /// </summary>
        [JsonProperty]
        public string CampaignIdentifier { get; private set; }

        [JsonProperty]
        public DateTime CampaignStartDate { get; private set; } 

        [JsonProperty]
        private long CurrentUID = CoreParams.ReserveUIDs;

        /// <summary>
        /// The next available unique ID
        /// </summary>
        /// <remarks>Accessing this will increment the backing counter (<see cref="CurrentUID"/>)</remarks>
        [JsonIgnore]
        public long NextUID { get { return ++CurrentUID; } }

        /// <summary>
        /// Current timescale
        /// </summary>
        [JsonProperty]
        public float CurrentTimescale { get; set; } = 1.0f;

        /// <summary>
        /// Difficulty at last save
        /// </summary>
        [JsonProperty]
        public int CurrentDifficulty { get; set; }

        /// <summary>
        /// Difficulty at campaign start
        /// </summary>
        [JsonProperty]
        public int InitialDifficulty { get; set; }

        /// <summary>
        /// Highest difficulty this campaign has ever had
        /// </summary>
        [JsonProperty]
        public int HighestDifficulty { get; set; }

        /// <summary>
        /// Lowest difficulty this campaign has ever had
        /// </summary>
        [JsonProperty]
        public int LowestDifficulty { get; set; }

        /// <summary>
        /// Lazy-deserialized data for addons
        /// </summary>
        [JsonIgnore]
        public LazyLooseDictionary AddonState { get; private set; } = new LazyLooseDictionary();

        [JsonProperty(PropertyName = nameof(AddonState))]
        private JObject AddonStateSerializable
        {
            get => AddonState.GetFullJObject();
            set => AddonState = new LazyLooseDictionary(value);
        }

        [JsonExtensionData]
        public IDictionary<string, JToken> AdditionalData { get; set; }

        /// <summary>
        /// Decorate methods with this atrribute to have them run on GameState initialization. Higher priority is sooner.
        /// </summary>
        public class InitAttribute : Attribute
        {
            /// <summary>
            /// Higher priority init methods are run first
            /// </summary>
            public int Priority { get; private set; } = 0;

            public InitAttribute()
            {

            }

            /// <param name="priority">When to run this init method; higher is sooner</param>
            public InitAttribute(int priority)
            {
                Priority = priority;
            }
        }

        /// <summary>
        /// Decorate methods with this attribute to have them run after deserializing GameState. Higher priority is sooner.
        /// </summary>
        public class AfterLoadAttribute : Attribute
        {
            /// <summary>
            /// Higher priority load methods are run first
            /// </summary>
            public int Priority { get; private set; } = 0;

            public AfterLoadAttribute()
            {

            }

            /// <param name="priority">When to run this load method; higher is sooner</param>
            public AfterLoadAttribute(int priority)
            {
                Priority = priority;
            }
        }
    }
}
